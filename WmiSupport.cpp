#ifdef __cplusplus
extern "C"
{
#endif
#include <wdm.h>
#include <acpitabl.h>
#include <acpiioct.h>
#include "AcpiSmiWdmCommon.h"

#ifdef __cplusplus
}
#endif

#include "AcpiWmiCallback.h"
#define MOFRESOURCENAME L"MofResourceName"
//
// to generate this Wmi42Guid declaration, 
// due to VS2017 cannot default binding wmimofck to generate properly header file, 
// add following line: 
/// <Wmimofck Include=".\$(IntDir)\wmi42.bmf">
/// <HeaderOutputFile>.\$(IntDir)\wmi42.h</HeaderOutputFile>
/// <VBScriptTestOutputFile>.\$(IntDir)\wmi42.vbs</VBScriptTestOutputFile>
/// </Wmimofck>
// detail, can refer to 'WDKSample\storage\msdsm\src'
//

GUID AcpiSimWMIGUID = Wmi42Guid;
WMIGUIDREGINFO guidlist[] = {
  {&AcpiSimWMIGUID, 3, WMIREG_FLAG_INSTANCE_PDO}
};


extern UNICODE_STRING GlobalRegistryPath;

NTSTATUS 
ACPI_Wmi_DeRegistration(
  IN PDEVICE_EXTENSION pDevExt
)
{
  PAGED_CODE();

  return IoWMIRegistrationControl(pDevExt->NextStackDevice,
    WMIREG_ACTION_DEREGISTER);
}


void _CreateInstaName(OUT PUNICODE_STRING )
{
  //
  // note: BSOD: attempt to write read-only memmory
  //
  /*
  InstanceName->MaximumLength = 0x30;
  InstanceName->Buffer = (PWCH)ExAllocatePoolWithTag(PagedPool, InstanceName->MaximumLength, 'StaS');
  RtlInitUnicodeString(InstanceName, L"AcpiSim");
  */
}
NTSTATUS
Acpi_Wmi_Registration(
  IN PDEVICE_EXTENSION pDevExt
)
{
  NTSTATUS Status = STATUS_SUCCESS;
  PAGED_CODE();

  pDevExt->WmiLibContext.GuidCount = arraysize(guidlist);
  pDevExt->WmiLibContext.GuidList = guidlist;
  pDevExt->WmiLibContext.QueryWmiRegInfo = QueryRegInfo;
  pDevExt->WmiLibContext.QueryWmiDataBlock = QueryDataBlock;
  pDevExt->WmiLibContext.SetWmiDataBlock = SetDataBlock;
  pDevExt->WmiLibContext.SetWmiDataItem = SetDataItem;
  pDevExt->WmiLibContext.ExecuteWmiMethod = NULL;
  pDevExt->WmiLibContext.WmiFunctionControl = NULL;
  pDevExt->TheAnswer = 0;
  KdPrint(("Enter Acpi_Wmi_Registration\n"));
  ///
  /// Register with WMI
  ///
  Status = IoWMIRegistrationControl(
    pDevExt->fdo,
    WMIREG_ACTION_REGISTER
  );
  KdPrint(("Leave Acpi_Wmi_Registration\n"));
  return Status;
}


NTSTATUS
QueryRegInfo(
  IN PDEVICE_OBJECT     DeviceObject,
  OUT ULONG             *RegFlags,
  OUT PUNICODE_STRING   Instancename ,
  OUT PUNICODE_STRING   *RegistryPath,
  OUT PUNICODE_STRING   MofResoureName,
  OUT PDEVICE_OBJECT    *Pdo
)
{

  KdPrint(("Enter QueryRegInfo \n"));
  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
  *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
  *RegistryPath = &GlobalRegistryPath;
  *Pdo = pDevExt->PDO;
  _CreateInstaName(Instancename);
  //
  // The MOFRESOURCENAME must be generated by *.rc file
  // with 'MOFDATA' ==> format: MOFRESOURCENAME MOFDATA **.mof
  // later, 
  // We can use 
  // 'WMI Code Creator utility ' to see a class Wmi42 under namespace root\WMI,
  //
  RtlInitUnicodeString(MofResoureName, MOFRESOURCENAME);
  KdPrint(("Leave QueryRegInfo \n"));
  return STATUS_SUCCESS;
}


NTSTATUS
QueryDataBlock(
  IN PDEVICE_OBJECT       fdo,
  IN PIRP                 irp,
  IN ULONG                Guidindex,
  IN ULONG                InstanceIndex,
  IN ULONG                InstanceCount,
  IN OUT PULONG           instlength,
  IN ULONG                OutBufferSize,
  OUT PUCHAR              Buffer
)
{
#define MAX_TRY_SIZE 10
  NTSTATUS  Status = STATUS_SUCCESS;
  KdPrint(("Enter QueryDataBlock \n"));
  KdPrint(("output support size = %d, InstanceCount = %d, InstanceIndex = %d GuidIndex = %d\n", OutBufferSize, InstanceCount, InstanceIndex, Guidindex));
  PAGED_CODE();

  if (!instlength || OutBufferSize == 0)
    return WmiCompleteRequest(fdo, irp, STATUS_BUFFER_TOO_SMALL, sizeof(ULONG), IO_NO_INCREMENT);

  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)fdo->DeviceExtension;
  PULONG pValue = (PULONG)Buffer;

  //
  // for WMI42 class, hard-code returns 'TheAnswer' is 0x02
  //
  //  *pValue = 0x2;
  *pValue = pDevExt->TheAnswer;
  instlength[0] = sizeof(ULONG);

  Status = WmiCompleteRequest(
                  fdo,
                  irp,
                  STATUS_SUCCESS,
                  sizeof(ULONG),
                  IO_NO_INCREMENT);
  KdPrint(("Leave QueryDataBlock \n"));
  return Status;
}

NTSTATUS
SetDataBlock(
  IN PDEVICE_OBJECT fdo,
  IN PIRP irp,
  IN ULONG guidIndex,
  IN ULONG instIndex,
  IN ULONG bufSize,
  IN PUCHAR buffer
)
{
  NTSTATUS status = STATUS_SUCCESS;
  ULONG info = 0;
  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)fdo->DeviceExtension;
  if (bufSize == sizeof(ULONG))
  {
    pDevExt->TheAnswer = *(PULONG)buffer;
    status = STATUS_SUCCESS;
    info = sizeof(ULONG);
  }
  else
  {
    status = STATUS_INFO_LENGTH_MISMATCH, info = 0;
  }
  return WmiCompleteRequest(fdo, irp, status, info, IO_NO_INCREMENT);
}

NTSTATUS
SetDataItem(
  IN PDEVICE_OBJECT fdo,
  IN PIRP           irp,
  IN ULONG          guidIndex,
  IN ULONG          instIndex,
  IN ULONG          id,
  IN ULONG          bufSize,
  IN PUCHAR         buffer
)
{
  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)fdo->DeviceExtension;
  NTSTATUS  status;
  ULONG info;
  if (bufSize == sizeof(ULONG)) {
    pDevExt->TheAnswer = *(PULONG)buffer;
    status = STATUS_SUCCESS;
    info = sizeof(ULONG);
  }
  else
  {
    status = STATUS_INFO_LENGTH_MISMATCH, info = 0;
  }
  return WmiCompleteRequest(fdo, irp, status, info, IO_NO_INCREMENT);
}

